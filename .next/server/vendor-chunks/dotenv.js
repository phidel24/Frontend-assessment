"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/dotenv";
exports.ids = ["vendor-chunks/dotenv"];
exports.modules = {

/***/ "(rsc)/./node_modules/dotenv/lib/main.js":
/*!*****************************************!*\
  !*** ./node_modules/dotenv/lib/main.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst os = __webpack_require__(/*! os */ \"os\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst packageJson = __webpack_require__(/*! ../package.json */ \"(rsc)/./node_modules/dotenv/package.json\");\nconst version = packageJson.version;\nconst LINE = /(?:^|^)\\s*(?:export\\s+)?([\\w.-]+)(?:\\s*=\\s*?|:\\s+?)(\\s*'(?:\\\\'|[^'])*'|\\s*\"(?:\\\\\"|[^\"])*\"|\\s*`(?:\\\\`|[^`])*`|[^#\\r\\n]+)?\\s*(?:#.*)?(?:$|$)/mg;\n// Parse src into an Object\nfunction parse(src) {\n    const obj = {};\n    // Convert buffer to string\n    let lines = src.toString();\n    // Convert line breaks to same format\n    lines = lines.replace(/\\r\\n?/mg, \"\\n\");\n    let match;\n    while((match = LINE.exec(lines)) != null){\n        const key = match[1];\n        // Default undefined or null to empty string\n        let value = match[2] || \"\";\n        // Remove whitespace\n        value = value.trim();\n        // Check if double quoted\n        const maybeQuote = value[0];\n        // Remove surrounding quotes\n        value = value.replace(/^(['\"`])([\\s\\S]*)\\1$/mg, \"$2\");\n        // Expand newlines if double quoted\n        if (maybeQuote === '\"') {\n            value = value.replace(/\\\\n/g, \"\\n\");\n            value = value.replace(/\\\\r/g, \"\\r\");\n        }\n        // Add to object\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _parseVault(options) {\n    options = options || {};\n    const vaultPath = _vaultPath(options);\n    options.path = vaultPath // parse .env.vault\n    ;\n    const result = DotenvModule.configDotenv(options);\n    if (!result.parsed) {\n        const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);\n        err.code = \"MISSING_DATA\";\n        throw err;\n    }\n    // handle scenario for comma separated keys - for use with key rotation\n    // example: DOTENV_KEY=\"dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=prod,dotenv://:key_7890@dotenvx.com/vault/.env.vault?environment=prod\"\n    const keys = _dotenvKey(options).split(\",\");\n    const length = keys.length;\n    let decrypted;\n    for(let i = 0; i < length; i++){\n        try {\n            // Get full key\n            const key = keys[i].trim();\n            // Get instructions for decrypt\n            const attrs = _instructions(result, key);\n            // Decrypt\n            decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);\n            break;\n        } catch (error) {\n            // last key\n            if (i + 1 >= length) {\n                throw error;\n            }\n        // try next key\n        }\n    }\n    // Parse decrypted .env string\n    return DotenvModule.parse(decrypted);\n}\nfunction _warn(message) {\n    console.log(`[dotenv@${version}][WARN] ${message}`);\n}\nfunction _debug(message) {\n    console.log(`[dotenv@${version}][DEBUG] ${message}`);\n}\nfunction _log(message) {\n    console.log(`[dotenv@${version}] ${message}`);\n}\nfunction _dotenvKey(options) {\n    // prioritize developer directly setting options.DOTENV_KEY\n    if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {\n        return options.DOTENV_KEY;\n    }\n    // secondary infra already contains a DOTENV_KEY environment variable\n    if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {\n        return process.env.DOTENV_KEY;\n    }\n    // fallback to empty string\n    return \"\";\n}\nfunction _instructions(result, dotenvKey) {\n    // Parse DOTENV_KEY. Format is a URI\n    let uri;\n    try {\n        uri = new URL(dotenvKey);\n    } catch (error) {\n        if (error.code === \"ERR_INVALID_URL\") {\n            const err = new Error(\"INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development\");\n            err.code = \"INVALID_DOTENV_KEY\";\n            throw err;\n        }\n        throw error;\n    }\n    // Get decrypt key\n    const key = uri.password;\n    if (!key) {\n        const err = new Error(\"INVALID_DOTENV_KEY: Missing key part\");\n        err.code = \"INVALID_DOTENV_KEY\";\n        throw err;\n    }\n    // Get environment\n    const environment = uri.searchParams.get(\"environment\");\n    if (!environment) {\n        const err = new Error(\"INVALID_DOTENV_KEY: Missing environment part\");\n        err.code = \"INVALID_DOTENV_KEY\";\n        throw err;\n    }\n    // Get ciphertext payload\n    const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;\n    const ciphertext = result.parsed[environmentKey] // DOTENV_VAULT_PRODUCTION\n    ;\n    if (!ciphertext) {\n        const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);\n        err.code = \"NOT_FOUND_DOTENV_ENVIRONMENT\";\n        throw err;\n    }\n    return {\n        ciphertext,\n        key\n    };\n}\nfunction _vaultPath(options) {\n    let possibleVaultPath = null;\n    if (options && options.path && options.path.length > 0) {\n        if (Array.isArray(options.path)) {\n            for (const filepath of options.path){\n                if (fs.existsSync(filepath)) {\n                    possibleVaultPath = filepath.endsWith(\".vault\") ? filepath : `${filepath}.vault`;\n                }\n            }\n        } else {\n            possibleVaultPath = options.path.endsWith(\".vault\") ? options.path : `${options.path}.vault`;\n        }\n    } else {\n        possibleVaultPath = path.resolve(process.cwd(), \".env.vault\");\n    }\n    if (fs.existsSync(possibleVaultPath)) {\n        return possibleVaultPath;\n    }\n    return null;\n}\nfunction _resolveHome(envPath) {\n    return envPath[0] === \"~\" ? path.join(os.homedir(), envPath.slice(1)) : envPath;\n}\nfunction _configVault(options) {\n    const debug = Boolean(options && options.debug);\n    const quiet = options && \"quiet\" in options ? options.quiet : true;\n    if (debug || !quiet) {\n        _log(\"Loading env from encrypted .env.vault\");\n    }\n    const parsed = DotenvModule._parseVault(options);\n    let processEnv = process.env;\n    if (options && options.processEnv != null) {\n        processEnv = options.processEnv;\n    }\n    DotenvModule.populate(processEnv, parsed, options);\n    return {\n        parsed\n    };\n}\nfunction configDotenv(options) {\n    const dotenvPath = path.resolve(process.cwd(), \".env\");\n    let encoding = \"utf8\";\n    const debug = Boolean(options && options.debug);\n    const quiet = options && \"quiet\" in options ? options.quiet : true;\n    if (options && options.encoding) {\n        encoding = options.encoding;\n    } else {\n        if (debug) {\n            _debug(\"No encoding is specified. UTF-8 is used by default\");\n        }\n    }\n    let optionPaths = [\n        dotenvPath\n    ] // default, look for .env\n    ;\n    if (options && options.path) {\n        if (!Array.isArray(options.path)) {\n            optionPaths = [\n                _resolveHome(options.path)\n            ];\n        } else {\n            optionPaths = [] // reset default\n            ;\n            for (const filepath of options.path){\n                optionPaths.push(_resolveHome(filepath));\n            }\n        }\n    }\n    // Build the parsed data in a temporary object (because we need to return it).  Once we have the final\n    // parsed data, we will combine it with process.env (or options.processEnv if provided).\n    let lastError;\n    const parsedAll = {};\n    for (const path of optionPaths){\n        try {\n            // Specifying an encoding returns a string instead of a buffer\n            const parsed = DotenvModule.parse(fs.readFileSync(path, {\n                encoding\n            }));\n            DotenvModule.populate(parsedAll, parsed, options);\n        } catch (e) {\n            if (debug) {\n                _debug(`Failed to load ${path} ${e.message}`);\n            }\n            lastError = e;\n        }\n    }\n    let processEnv = process.env;\n    if (options && options.processEnv != null) {\n        processEnv = options.processEnv;\n    }\n    DotenvModule.populate(processEnv, parsedAll, options);\n    if (debug || !quiet) {\n        const keysCount = Object.keys(parsedAll).length;\n        const shortPaths = [];\n        for (const filePath of optionPaths){\n            try {\n                const relative = path.relative(process.cwd(), filePath);\n                shortPaths.push(relative);\n            } catch (e) {\n                if (debug) {\n                    _debug(`Failed to load ${filePath} ${e.message}`);\n                }\n                lastError = e;\n            }\n        }\n        _log(`injecting env (${keysCount}) from ${shortPaths.join(\",\")}`);\n    }\n    if (lastError) {\n        return {\n            parsed: parsedAll,\n            error: lastError\n        };\n    } else {\n        return {\n            parsed: parsedAll\n        };\n    }\n}\n// Populates process.env from .env file\nfunction config(options) {\n    // fallback to original dotenv if DOTENV_KEY is not set\n    if (_dotenvKey(options).length === 0) {\n        return DotenvModule.configDotenv(options);\n    }\n    const vaultPath = _vaultPath(options);\n    // dotenvKey exists but .env.vault file does not exist\n    if (!vaultPath) {\n        _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);\n        return DotenvModule.configDotenv(options);\n    }\n    return DotenvModule._configVault(options);\n}\nfunction decrypt(encrypted, keyStr) {\n    const key = Buffer.from(keyStr.slice(-64), \"hex\");\n    let ciphertext = Buffer.from(encrypted, \"base64\");\n    const nonce = ciphertext.subarray(0, 12);\n    const authTag = ciphertext.subarray(-16);\n    ciphertext = ciphertext.subarray(12, -16);\n    try {\n        const aesgcm = crypto.createDecipheriv(\"aes-256-gcm\", key, nonce);\n        aesgcm.setAuthTag(authTag);\n        return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;\n    } catch (error) {\n        const isRange = error instanceof RangeError;\n        const invalidKeyLength = error.message === \"Invalid key length\";\n        const decryptionFailed = error.message === \"Unsupported state or unable to authenticate data\";\n        if (isRange || invalidKeyLength) {\n            const err = new Error(\"INVALID_DOTENV_KEY: It must be 64 characters long (or more)\");\n            err.code = \"INVALID_DOTENV_KEY\";\n            throw err;\n        } else if (decryptionFailed) {\n            const err = new Error(\"DECRYPTION_FAILED: Please check your DOTENV_KEY\");\n            err.code = \"DECRYPTION_FAILED\";\n            throw err;\n        } else {\n            throw error;\n        }\n    }\n}\n// Populate process.env with parsed values\nfunction populate(processEnv, parsed, options = {}) {\n    const debug = Boolean(options && options.debug);\n    const override = Boolean(options && options.override);\n    if (typeof parsed !== \"object\") {\n        const err = new Error(\"OBJECT_REQUIRED: Please check the processEnv argument being passed to populate\");\n        err.code = \"OBJECT_REQUIRED\";\n        throw err;\n    }\n    // Set process.env\n    for (const key of Object.keys(parsed)){\n        if (Object.prototype.hasOwnProperty.call(processEnv, key)) {\n            if (override === true) {\n                processEnv[key] = parsed[key];\n            }\n            if (debug) {\n                if (override === true) {\n                    _debug(`\"${key}\" is already defined and WAS overwritten`);\n                } else {\n                    _debug(`\"${key}\" is already defined and was NOT overwritten`);\n                }\n            }\n        } else {\n            processEnv[key] = parsed[key];\n        }\n    }\n}\nconst DotenvModule = {\n    configDotenv,\n    _configVault,\n    _parseVault,\n    config,\n    decrypt,\n    parse,\n    populate\n};\nmodule.exports.configDotenv = DotenvModule.configDotenv;\nmodule.exports._configVault = DotenvModule._configVault;\nmodule.exports._parseVault = DotenvModule._parseVault;\nmodule.exports.config = DotenvModule.config;\nmodule.exports.decrypt = DotenvModule.decrypt;\nmodule.exports.parse = DotenvModule.parse;\nmodule.exports.populate = DotenvModule.populate;\nmodule.exports = DotenvModule;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LE1BQU07Z0JBQ3JCaEMsVUFBVSxDQUFDN0QsSUFBSSxHQUFHVyxNQUFNLENBQUNYLElBQUk7WUFDL0I7WUFFQSxJQUFJMEQsT0FBTztnQkFDVCxJQUFJbUMsYUFBYSxNQUFNO29CQUNyQi9ELE9BQU8sQ0FBQyxDQUFDLEVBQUU5QixJQUFJLHdDQUF3QyxDQUFDO2dCQUMxRCxPQUFPO29CQUNMOEIsT0FBTyxDQUFDLENBQUMsRUFBRTlCLElBQUksNENBQTRDLENBQUM7Z0JBQzlEO1lBQ0Y7UUFDRixPQUFPO1lBQ0w2RCxVQUFVLENBQUM3RCxJQUFJLEdBQUdXLE1BQU0sQ0FBQ1gsSUFBSTtRQUMvQjtJQUNGO0FBQ0Y7QUFFQSxNQUFNUyxlQUFlO0lBQ25CQztJQUNBK0M7SUFDQXJEO0lBQ0F3RTtJQUNBckQ7SUFDQS9CO0lBQ0FzRTtBQUNGO0FBRUFtQywyQkFBMkIsR0FBR3hGLGFBQWFDLFlBQVk7QUFDdkR1RiwyQkFBMkIsR0FBR3hGLGFBQWFnRCxZQUFZO0FBQ3ZEd0MsMEJBQTBCLEdBQUd4RixhQUFhTCxXQUFXO0FBQ3JENkYscUJBQXFCLEdBQUd4RixhQUFhbUUsTUFBTTtBQUMzQ3FCLHNCQUFzQixHQUFHeEYsYUFBYWMsT0FBTztBQUM3QzBFLG9CQUFvQixHQUFHeEYsYUFBYWpCLEtBQUs7QUFDekN5Ryx1QkFBdUIsR0FBR3hGLGFBQWFxRCxRQUFRO0FBRS9DbUMsT0FBT0MsT0FBTyxHQUFHekYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC1hc3Nlc3NtZW50Ly4vbm9kZV9tb2R1bGVzL2RvdGVudi9saWIvbWFpbi5qcz8yZDg0Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpXG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKVxuY29uc3QgcGFja2FnZUpzb24gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKVxuXG5jb25zdCB2ZXJzaW9uID0gcGFja2FnZUpzb24udmVyc2lvblxuXG5jb25zdCBMSU5FID0gLyg/Ol58XilcXHMqKD86ZXhwb3J0XFxzKyk/KFtcXHcuLV0rKSg/Olxccyo9XFxzKj98Olxccys/KShcXHMqJyg/OlxcXFwnfFteJ10pKid8XFxzKlwiKD86XFxcXFwifFteXCJdKSpcInxcXHMqYCg/OlxcXFxgfFteYF0pKmB8W14jXFxyXFxuXSspP1xccyooPzojLiopPyg/OiR8JCkvbWdcblxuLy8gUGFyc2Ugc3JjIGludG8gYW4gT2JqZWN0XG5mdW5jdGlvbiBwYXJzZSAoc3JjKSB7XG4gIGNvbnN0IG9iaiA9IHt9XG5cbiAgLy8gQ29udmVydCBidWZmZXIgdG8gc3RyaW5nXG4gIGxldCBsaW5lcyA9IHNyYy50b1N0cmluZygpXG5cbiAgLy8gQ29udmVydCBsaW5lIGJyZWFrcyB0byBzYW1lIGZvcm1hdFxuICBsaW5lcyA9IGxpbmVzLnJlcGxhY2UoL1xcclxcbj8vbWcsICdcXG4nKVxuXG4gIGxldCBtYXRjaFxuICB3aGlsZSAoKG1hdGNoID0gTElORS5leGVjKGxpbmVzKSkgIT0gbnVsbCkge1xuICAgIGNvbnN0IGtleSA9IG1hdGNoWzFdXG5cbiAgICAvLyBEZWZhdWx0IHVuZGVmaW5lZCBvciBudWxsIHRvIGVtcHR5IHN0cmluZ1xuICAgIGxldCB2YWx1ZSA9IChtYXRjaFsyXSB8fCAnJylcblxuICAgIC8vIFJlbW92ZSB3aGl0ZXNwYWNlXG4gICAgdmFsdWUgPSB2YWx1ZS50cmltKClcblxuICAgIC8vIENoZWNrIGlmIGRvdWJsZSBxdW90ZWRcbiAgICBjb25zdCBtYXliZVF1b3RlID0gdmFsdWVbMF1cblxuICAgIC8vIFJlbW92ZSBzdXJyb3VuZGluZyBxdW90ZXNcbiAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL14oWydcImBdKShbXFxzXFxTXSopXFwxJC9tZywgJyQyJylcblxuICAgIC8vIEV4cGFuZCBuZXdsaW5lcyBpZiBkb3VibGUgcXVvdGVkXG4gICAgaWYgKG1heWJlUXVvdGUgPT09ICdcIicpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxcXG4vZywgJ1xcbicpXG4gICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcXFxyL2csICdcXHInKVxuICAgIH1cblxuICAgIC8vIEFkZCB0byBvYmplY3RcbiAgICBvYmpba2V5XSA9IHZhbHVlXG4gIH1cblxuICByZXR1cm4gb2JqXG59XG5cbmZ1bmN0aW9uIF9wYXJzZVZhdWx0IChvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgY29uc3QgdmF1bHRQYXRoID0gX3ZhdWx0UGF0aChvcHRpb25zKVxuICBvcHRpb25zLnBhdGggPSB2YXVsdFBhdGggLy8gcGFyc2UgLmVudi52YXVsdFxuICBjb25zdCByZXN1bHQgPSBEb3RlbnZNb2R1bGUuY29uZmlnRG90ZW52KG9wdGlvbnMpXG4gIGlmICghcmVzdWx0LnBhcnNlZCkge1xuICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihgTUlTU0lOR19EQVRBOiBDYW5ub3QgcGFyc2UgJHt2YXVsdFBhdGh9IGZvciBhbiB1bmtub3duIHJlYXNvbmApXG4gICAgZXJyLmNvZGUgPSAnTUlTU0lOR19EQVRBJ1xuICAgIHRocm93IGVyclxuICB9XG5cbiAgLy8gaGFuZGxlIHNjZW5hcmlvIGZvciBjb21tYSBzZXBhcmF0ZWQga2V5cyAtIGZvciB1c2Ugd2l0aCBrZXkgcm90YXRpb25cbiAgLy8gZXhhbXBsZTogRE9URU5WX0tFWT1cImRvdGVudjovLzprZXlfMTIzNEBkb3RlbnZ4LmNvbS92YXVsdC8uZW52LnZhdWx0P2Vudmlyb25tZW50PXByb2QsZG90ZW52Oi8vOmtleV83ODkwQGRvdGVudnguY29tL3ZhdWx0Ly5lbnYudmF1bHQ/ZW52aXJvbm1lbnQ9cHJvZFwiXG4gIGNvbnN0IGtleXMgPSBfZG90ZW52S2V5KG9wdGlvbnMpLnNwbGl0KCcsJylcbiAgY29uc3QgbGVuZ3RoID0ga2V5cy5sZW5ndGhcblxuICBsZXQgZGVjcnlwdGVkXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB0cnkge1xuICAgICAgLy8gR2V0IGZ1bGwga2V5XG4gICAgICBjb25zdCBrZXkgPSBrZXlzW2ldLnRyaW0oKVxuXG4gICAgICAvLyBHZXQgaW5zdHJ1Y3Rpb25zIGZvciBkZWNyeXB0XG4gICAgICBjb25zdCBhdHRycyA9IF9pbnN0cnVjdGlvbnMocmVzdWx0LCBrZXkpXG5cbiAgICAgIC8vIERlY3J5cHRcbiAgICAgIGRlY3J5cHRlZCA9IERvdGVudk1vZHVsZS5kZWNyeXB0KGF0dHJzLmNpcGhlcnRleHQsIGF0dHJzLmtleSlcblxuICAgICAgYnJlYWtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gbGFzdCBrZXlcbiAgICAgIGlmIChpICsgMSA+PSBsZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICAgIC8vIHRyeSBuZXh0IGtleVxuICAgIH1cbiAgfVxuXG4gIC8vIFBhcnNlIGRlY3J5cHRlZCAuZW52IHN0cmluZ1xuICByZXR1cm4gRG90ZW52TW9kdWxlLnBhcnNlKGRlY3J5cHRlZClcbn1cblxuZnVuY3Rpb24gX3dhcm4gKG1lc3NhZ2UpIHtcbiAgY29uc29sZS5sb2coYFtkb3RlbnZAJHt2ZXJzaW9ufV1bV0FSTl0gJHttZXNzYWdlfWApXG59XG5cbmZ1bmN0aW9uIF9kZWJ1ZyAobWVzc2FnZSkge1xuICBjb25zb2xlLmxvZyhgW2RvdGVudkAke3ZlcnNpb259XVtERUJVR10gJHttZXNzYWdlfWApXG59XG5cbmZ1bmN0aW9uIF9sb2cgKG1lc3NhZ2UpIHtcbiAgY29uc29sZS5sb2coYFtkb3RlbnZAJHt2ZXJzaW9ufV0gJHttZXNzYWdlfWApXG59XG5cbmZ1bmN0aW9uIF9kb3RlbnZLZXkgKG9wdGlvbnMpIHtcbiAgLy8gcHJpb3JpdGl6ZSBkZXZlbG9wZXIgZGlyZWN0bHkgc2V0dGluZyBvcHRpb25zLkRPVEVOVl9LRVlcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5ET1RFTlZfS0VZICYmIG9wdGlvbnMuRE9URU5WX0tFWS5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuRE9URU5WX0tFWVxuICB9XG5cbiAgLy8gc2Vjb25kYXJ5IGluZnJhIGFscmVhZHkgY29udGFpbnMgYSBET1RFTlZfS0VZIGVudmlyb25tZW50IHZhcmlhYmxlXG4gIGlmIChwcm9jZXNzLmVudi5ET1RFTlZfS0VZICYmIHByb2Nlc3MuZW52LkRPVEVOVl9LRVkubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5ET1RFTlZfS0VZXG4gIH1cblxuICAvLyBmYWxsYmFjayB0byBlbXB0eSBzdHJpbmdcbiAgcmV0dXJuICcnXG59XG5cbmZ1bmN0aW9uIF9pbnN0cnVjdGlvbnMgKHJlc3VsdCwgZG90ZW52S2V5KSB7XG4gIC8vIFBhcnNlIERPVEVOVl9LRVkuIEZvcm1hdCBpcyBhIFVSSVxuICBsZXQgdXJpXG4gIHRyeSB7XG4gICAgdXJpID0gbmV3IFVSTChkb3RlbnZLZXkpXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGVycm9yLmNvZGUgPT09ICdFUlJfSU5WQUxJRF9VUkwnKSB7XG4gICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ0lOVkFMSURfRE9URU5WX0tFWTogV3JvbmcgZm9ybWF0LiBNdXN0IGJlIGluIHZhbGlkIHVyaSBmb3JtYXQgbGlrZSBkb3RlbnY6Ly86a2V5XzEyMzRAZG90ZW52eC5jb20vdmF1bHQvLmVudi52YXVsdD9lbnZpcm9ubWVudD1kZXZlbG9wbWVudCcpXG4gICAgICBlcnIuY29kZSA9ICdJTlZBTElEX0RPVEVOVl9LRVknXG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG5cbiAgICB0aHJvdyBlcnJvclxuICB9XG5cbiAgLy8gR2V0IGRlY3J5cHQga2V5XG4gIGNvbnN0IGtleSA9IHVyaS5wYXNzd29yZFxuICBpZiAoIWtleSkge1xuICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcignSU5WQUxJRF9ET1RFTlZfS0VZOiBNaXNzaW5nIGtleSBwYXJ0JylcbiAgICBlcnIuY29kZSA9ICdJTlZBTElEX0RPVEVOVl9LRVknXG4gICAgdGhyb3cgZXJyXG4gIH1cblxuICAvLyBHZXQgZW52aXJvbm1lbnRcbiAgY29uc3QgZW52aXJvbm1lbnQgPSB1cmkuc2VhcmNoUGFyYW1zLmdldCgnZW52aXJvbm1lbnQnKVxuICBpZiAoIWVudmlyb25tZW50KSB7XG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdJTlZBTElEX0RPVEVOVl9LRVk6IE1pc3NpbmcgZW52aXJvbm1lbnQgcGFydCcpXG4gICAgZXJyLmNvZGUgPSAnSU5WQUxJRF9ET1RFTlZfS0VZJ1xuICAgIHRocm93IGVyclxuICB9XG5cbiAgLy8gR2V0IGNpcGhlcnRleHQgcGF5bG9hZFxuICBjb25zdCBlbnZpcm9ubWVudEtleSA9IGBET1RFTlZfVkFVTFRfJHtlbnZpcm9ubWVudC50b1VwcGVyQ2FzZSgpfWBcbiAgY29uc3QgY2lwaGVydGV4dCA9IHJlc3VsdC5wYXJzZWRbZW52aXJvbm1lbnRLZXldIC8vIERPVEVOVl9WQVVMVF9QUk9EVUNUSU9OXG4gIGlmICghY2lwaGVydGV4dCkge1xuICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihgTk9UX0ZPVU5EX0RPVEVOVl9FTlZJUk9OTUVOVDogQ2Fubm90IGxvY2F0ZSBlbnZpcm9ubWVudCAke2Vudmlyb25tZW50S2V5fSBpbiB5b3VyIC5lbnYudmF1bHQgZmlsZS5gKVxuICAgIGVyci5jb2RlID0gJ05PVF9GT1VORF9ET1RFTlZfRU5WSVJPTk1FTlQnXG4gICAgdGhyb3cgZXJyXG4gIH1cblxuICByZXR1cm4geyBjaXBoZXJ0ZXh0LCBrZXkgfVxufVxuXG5mdW5jdGlvbiBfdmF1bHRQYXRoIChvcHRpb25zKSB7XG4gIGxldCBwb3NzaWJsZVZhdWx0UGF0aCA9IG51bGxcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnBhdGggJiYgb3B0aW9ucy5wYXRoLmxlbmd0aCA+IDApIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLnBhdGgpKSB7XG4gICAgICBmb3IgKGNvbnN0IGZpbGVwYXRoIG9mIG9wdGlvbnMucGF0aCkge1xuICAgICAgICBpZiAoZnMuZXhpc3RzU3luYyhmaWxlcGF0aCkpIHtcbiAgICAgICAgICBwb3NzaWJsZVZhdWx0UGF0aCA9IGZpbGVwYXRoLmVuZHNXaXRoKCcudmF1bHQnKSA/IGZpbGVwYXRoIDogYCR7ZmlsZXBhdGh9LnZhdWx0YFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvc3NpYmxlVmF1bHRQYXRoID0gb3B0aW9ucy5wYXRoLmVuZHNXaXRoKCcudmF1bHQnKSA/IG9wdGlvbnMucGF0aCA6IGAke29wdGlvbnMucGF0aH0udmF1bHRgXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBvc3NpYmxlVmF1bHRQYXRoID0gcGF0aC5yZXNvbHZlKHByb2Nlc3MuY3dkKCksICcuZW52LnZhdWx0JylcbiAgfVxuXG4gIGlmIChmcy5leGlzdHNTeW5jKHBvc3NpYmxlVmF1bHRQYXRoKSkge1xuICAgIHJldHVybiBwb3NzaWJsZVZhdWx0UGF0aFxuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cblxuZnVuY3Rpb24gX3Jlc29sdmVIb21lIChlbnZQYXRoKSB7XG4gIHJldHVybiBlbnZQYXRoWzBdID09PSAnficgPyBwYXRoLmpvaW4ob3MuaG9tZWRpcigpLCBlbnZQYXRoLnNsaWNlKDEpKSA6IGVudlBhdGhcbn1cblxuZnVuY3Rpb24gX2NvbmZpZ1ZhdWx0IChvcHRpb25zKSB7XG4gIGNvbnN0IGRlYnVnID0gQm9vbGVhbihvcHRpb25zICYmIG9wdGlvbnMuZGVidWcpXG4gIGNvbnN0IHF1aWV0ID0gb3B0aW9ucyAmJiAncXVpZXQnIGluIG9wdGlvbnMgPyBvcHRpb25zLnF1aWV0IDogdHJ1ZVxuXG4gIGlmIChkZWJ1ZyB8fCAhcXVpZXQpIHtcbiAgICBfbG9nKCdMb2FkaW5nIGVudiBmcm9tIGVuY3J5cHRlZCAuZW52LnZhdWx0JylcbiAgfVxuXG4gIGNvbnN0IHBhcnNlZCA9IERvdGVudk1vZHVsZS5fcGFyc2VWYXVsdChvcHRpb25zKVxuXG4gIGxldCBwcm9jZXNzRW52ID0gcHJvY2Vzcy5lbnZcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5wcm9jZXNzRW52ICE9IG51bGwpIHtcbiAgICBwcm9jZXNzRW52ID0gb3B0aW9ucy5wcm9jZXNzRW52XG4gIH1cblxuICBEb3RlbnZNb2R1bGUucG9wdWxhdGUocHJvY2Vzc0VudiwgcGFyc2VkLCBvcHRpb25zKVxuXG4gIHJldHVybiB7IHBhcnNlZCB9XG59XG5cbmZ1bmN0aW9uIGNvbmZpZ0RvdGVudiAob3B0aW9ucykge1xuICBjb25zdCBkb3RlbnZQYXRoID0gcGF0aC5yZXNvbHZlKHByb2Nlc3MuY3dkKCksICcuZW52JylcbiAgbGV0IGVuY29kaW5nID0gJ3V0ZjgnXG4gIGNvbnN0IGRlYnVnID0gQm9vbGVhbihvcHRpb25zICYmIG9wdGlvbnMuZGVidWcpXG4gIGNvbnN0IHF1aWV0ID0gb3B0aW9ucyAmJiAncXVpZXQnIGluIG9wdGlvbnMgPyBvcHRpb25zLnF1aWV0IDogdHJ1ZVxuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBlbmNvZGluZyA9IG9wdGlvbnMuZW5jb2RpbmdcbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVidWcpIHtcbiAgICAgIF9kZWJ1ZygnTm8gZW5jb2RpbmcgaXMgc3BlY2lmaWVkLiBVVEYtOCBpcyB1c2VkIGJ5IGRlZmF1bHQnKVxuICAgIH1cbiAgfVxuXG4gIGxldCBvcHRpb25QYXRocyA9IFtkb3RlbnZQYXRoXSAvLyBkZWZhdWx0LCBsb29rIGZvciAuZW52XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucGF0aCkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShvcHRpb25zLnBhdGgpKSB7XG4gICAgICBvcHRpb25QYXRocyA9IFtfcmVzb2x2ZUhvbWUob3B0aW9ucy5wYXRoKV1cbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9uUGF0aHMgPSBbXSAvLyByZXNldCBkZWZhdWx0XG4gICAgICBmb3IgKGNvbnN0IGZpbGVwYXRoIG9mIG9wdGlvbnMucGF0aCkge1xuICAgICAgICBvcHRpb25QYXRocy5wdXNoKF9yZXNvbHZlSG9tZShmaWxlcGF0aCkpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQnVpbGQgdGhlIHBhcnNlZCBkYXRhIGluIGEgdGVtcG9yYXJ5IG9iamVjdCAoYmVjYXVzZSB3ZSBuZWVkIHRvIHJldHVybiBpdCkuICBPbmNlIHdlIGhhdmUgdGhlIGZpbmFsXG4gIC8vIHBhcnNlZCBkYXRhLCB3ZSB3aWxsIGNvbWJpbmUgaXQgd2l0aCBwcm9jZXNzLmVudiAob3Igb3B0aW9ucy5wcm9jZXNzRW52IGlmIHByb3ZpZGVkKS5cbiAgbGV0IGxhc3RFcnJvclxuICBjb25zdCBwYXJzZWRBbGwgPSB7fVxuICBmb3IgKGNvbnN0IHBhdGggb2Ygb3B0aW9uUGF0aHMpIHtcbiAgICB0cnkge1xuICAgICAgLy8gU3BlY2lmeWluZyBhbiBlbmNvZGluZyByZXR1cm5zIGEgc3RyaW5nIGluc3RlYWQgb2YgYSBidWZmZXJcbiAgICAgIGNvbnN0IHBhcnNlZCA9IERvdGVudk1vZHVsZS5wYXJzZShmcy5yZWFkRmlsZVN5bmMocGF0aCwgeyBlbmNvZGluZyB9KSlcblxuICAgICAgRG90ZW52TW9kdWxlLnBvcHVsYXRlKHBhcnNlZEFsbCwgcGFyc2VkLCBvcHRpb25zKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICBfZGVidWcoYEZhaWxlZCB0byBsb2FkICR7cGF0aH0gJHtlLm1lc3NhZ2V9YClcbiAgICAgIH1cbiAgICAgIGxhc3RFcnJvciA9IGVcbiAgICB9XG4gIH1cblxuICBsZXQgcHJvY2Vzc0VudiA9IHByb2Nlc3MuZW52XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucHJvY2Vzc0VudiAhPSBudWxsKSB7XG4gICAgcHJvY2Vzc0VudiA9IG9wdGlvbnMucHJvY2Vzc0VudlxuICB9XG5cbiAgRG90ZW52TW9kdWxlLnBvcHVsYXRlKHByb2Nlc3NFbnYsIHBhcnNlZEFsbCwgb3B0aW9ucylcblxuICBpZiAoZGVidWcgfHwgIXF1aWV0KSB7XG4gICAgY29uc3Qga2V5c0NvdW50ID0gT2JqZWN0LmtleXMocGFyc2VkQWxsKS5sZW5ndGhcbiAgICBjb25zdCBzaG9ydFBhdGhzID0gW11cbiAgICBmb3IgKGNvbnN0IGZpbGVQYXRoIG9mIG9wdGlvblBhdGhzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZWxhdGl2ZSA9IHBhdGgucmVsYXRpdmUocHJvY2Vzcy5jd2QoKSwgZmlsZVBhdGgpXG4gICAgICAgIHNob3J0UGF0aHMucHVzaChyZWxhdGl2ZSlcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgX2RlYnVnKGBGYWlsZWQgdG8gbG9hZCAke2ZpbGVQYXRofSAke2UubWVzc2FnZX1gKVxuICAgICAgICB9XG4gICAgICAgIGxhc3RFcnJvciA9IGVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfbG9nKGBpbmplY3RpbmcgZW52ICgke2tleXNDb3VudH0pIGZyb20gJHtzaG9ydFBhdGhzLmpvaW4oJywnKX1gKVxuICB9XG5cbiAgaWYgKGxhc3RFcnJvcikge1xuICAgIHJldHVybiB7IHBhcnNlZDogcGFyc2VkQWxsLCBlcnJvcjogbGFzdEVycm9yIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geyBwYXJzZWQ6IHBhcnNlZEFsbCB9XG4gIH1cbn1cblxuLy8gUG9wdWxhdGVzIHByb2Nlc3MuZW52IGZyb20gLmVudiBmaWxlXG5mdW5jdGlvbiBjb25maWcgKG9wdGlvbnMpIHtcbiAgLy8gZmFsbGJhY2sgdG8gb3JpZ2luYWwgZG90ZW52IGlmIERPVEVOVl9LRVkgaXMgbm90IHNldFxuICBpZiAoX2RvdGVudktleShvcHRpb25zKS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gRG90ZW52TW9kdWxlLmNvbmZpZ0RvdGVudihvcHRpb25zKVxuICB9XG5cbiAgY29uc3QgdmF1bHRQYXRoID0gX3ZhdWx0UGF0aChvcHRpb25zKVxuXG4gIC8vIGRvdGVudktleSBleGlzdHMgYnV0IC5lbnYudmF1bHQgZmlsZSBkb2VzIG5vdCBleGlzdFxuICBpZiAoIXZhdWx0UGF0aCkge1xuICAgIF93YXJuKGBZb3Ugc2V0IERPVEVOVl9LRVkgYnV0IHlvdSBhcmUgbWlzc2luZyBhIC5lbnYudmF1bHQgZmlsZSBhdCAke3ZhdWx0UGF0aH0uIERpZCB5b3UgZm9yZ2V0IHRvIGJ1aWxkIGl0P2ApXG5cbiAgICByZXR1cm4gRG90ZW52TW9kdWxlLmNvbmZpZ0RvdGVudihvcHRpb25zKVxuICB9XG5cbiAgcmV0dXJuIERvdGVudk1vZHVsZS5fY29uZmlnVmF1bHQob3B0aW9ucylcbn1cblxuZnVuY3Rpb24gZGVjcnlwdCAoZW5jcnlwdGVkLCBrZXlTdHIpIHtcbiAgY29uc3Qga2V5ID0gQnVmZmVyLmZyb20oa2V5U3RyLnNsaWNlKC02NCksICdoZXgnKVxuICBsZXQgY2lwaGVydGV4dCA9IEJ1ZmZlci5mcm9tKGVuY3J5cHRlZCwgJ2Jhc2U2NCcpXG5cbiAgY29uc3Qgbm9uY2UgPSBjaXBoZXJ0ZXh0LnN1YmFycmF5KDAsIDEyKVxuICBjb25zdCBhdXRoVGFnID0gY2lwaGVydGV4dC5zdWJhcnJheSgtMTYpXG4gIGNpcGhlcnRleHQgPSBjaXBoZXJ0ZXh0LnN1YmFycmF5KDEyLCAtMTYpXG5cbiAgdHJ5IHtcbiAgICBjb25zdCBhZXNnY20gPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdignYWVzLTI1Ni1nY20nLCBrZXksIG5vbmNlKVxuICAgIGFlc2djbS5zZXRBdXRoVGFnKGF1dGhUYWcpXG4gICAgcmV0dXJuIGAke2Flc2djbS51cGRhdGUoY2lwaGVydGV4dCl9JHthZXNnY20uZmluYWwoKX1gXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc3QgaXNSYW5nZSA9IGVycm9yIGluc3RhbmNlb2YgUmFuZ2VFcnJvclxuICAgIGNvbnN0IGludmFsaWRLZXlMZW5ndGggPSBlcnJvci5tZXNzYWdlID09PSAnSW52YWxpZCBrZXkgbGVuZ3RoJ1xuICAgIGNvbnN0IGRlY3J5cHRpb25GYWlsZWQgPSBlcnJvci5tZXNzYWdlID09PSAnVW5zdXBwb3J0ZWQgc3RhdGUgb3IgdW5hYmxlIHRvIGF1dGhlbnRpY2F0ZSBkYXRhJ1xuXG4gICAgaWYgKGlzUmFuZ2UgfHwgaW52YWxpZEtleUxlbmd0aCkge1xuICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdJTlZBTElEX0RPVEVOVl9LRVk6IEl0IG11c3QgYmUgNjQgY2hhcmFjdGVycyBsb25nIChvciBtb3JlKScpXG4gICAgICBlcnIuY29kZSA9ICdJTlZBTElEX0RPVEVOVl9LRVknXG4gICAgICB0aHJvdyBlcnJcbiAgICB9IGVsc2UgaWYgKGRlY3J5cHRpb25GYWlsZWQpIHtcbiAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcignREVDUllQVElPTl9GQUlMRUQ6IFBsZWFzZSBjaGVjayB5b3VyIERPVEVOVl9LRVknKVxuICAgICAgZXJyLmNvZGUgPSAnREVDUllQVElPTl9GQUlMRUQnXG4gICAgICB0aHJvdyBlcnJcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cbn1cblxuLy8gUG9wdWxhdGUgcHJvY2Vzcy5lbnYgd2l0aCBwYXJzZWQgdmFsdWVzXG5mdW5jdGlvbiBwb3B1bGF0ZSAocHJvY2Vzc0VudiwgcGFyc2VkLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgZGVidWcgPSBCb29sZWFuKG9wdGlvbnMgJiYgb3B0aW9ucy5kZWJ1ZylcbiAgY29uc3Qgb3ZlcnJpZGUgPSBCb29sZWFuKG9wdGlvbnMgJiYgb3B0aW9ucy5vdmVycmlkZSlcblxuICBpZiAodHlwZW9mIHBhcnNlZCAhPT0gJ29iamVjdCcpIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ09CSkVDVF9SRVFVSVJFRDogUGxlYXNlIGNoZWNrIHRoZSBwcm9jZXNzRW52IGFyZ3VtZW50IGJlaW5nIHBhc3NlZCB0byBwb3B1bGF0ZScpXG4gICAgZXJyLmNvZGUgPSAnT0JKRUNUX1JFUVVJUkVEJ1xuICAgIHRocm93IGVyclxuICB9XG5cbiAgLy8gU2V0IHByb2Nlc3MuZW52XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHBhcnNlZCkpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb2Nlc3NFbnYsIGtleSkpIHtcbiAgICAgIGlmIChvdmVycmlkZSA9PT0gdHJ1ZSkge1xuICAgICAgICBwcm9jZXNzRW52W2tleV0gPSBwYXJzZWRba2V5XVxuICAgICAgfVxuXG4gICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgaWYgKG92ZXJyaWRlID09PSB0cnVlKSB7XG4gICAgICAgICAgX2RlYnVnKGBcIiR7a2V5fVwiIGlzIGFscmVhZHkgZGVmaW5lZCBhbmQgV0FTIG92ZXJ3cml0dGVuYClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfZGVidWcoYFwiJHtrZXl9XCIgaXMgYWxyZWFkeSBkZWZpbmVkIGFuZCB3YXMgTk9UIG92ZXJ3cml0dGVuYClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzRW52W2tleV0gPSBwYXJzZWRba2V5XVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBEb3RlbnZNb2R1bGUgPSB7XG4gIGNvbmZpZ0RvdGVudixcbiAgX2NvbmZpZ1ZhdWx0LFxuICBfcGFyc2VWYXVsdCxcbiAgY29uZmlnLFxuICBkZWNyeXB0LFxuICBwYXJzZSxcbiAgcG9wdWxhdGVcbn1cblxubW9kdWxlLmV4cG9ydHMuY29uZmlnRG90ZW52ID0gRG90ZW52TW9kdWxlLmNvbmZpZ0RvdGVudlxubW9kdWxlLmV4cG9ydHMuX2NvbmZpZ1ZhdWx0ID0gRG90ZW52TW9kdWxlLl9jb25maWdWYXVsdFxubW9kdWxlLmV4cG9ydHMuX3BhcnNlVmF1bHQgPSBEb3RlbnZNb2R1bGUuX3BhcnNlVmF1bHRcbm1vZHVsZS5leHBvcnRzLmNvbmZpZyA9IERvdGVudk1vZHVsZS5jb25maWdcbm1vZHVsZS5leHBvcnRzLmRlY3J5cHQgPSBEb3RlbnZNb2R1bGUuZGVjcnlwdFxubW9kdWxlLmV4cG9ydHMucGFyc2UgPSBEb3RlbnZNb2R1bGUucGFyc2Vcbm1vZHVsZS5leHBvcnRzLnBvcHVsYXRlID0gRG90ZW52TW9kdWxlLnBvcHVsYXRlXG5cbm1vZHVsZS5leHBvcnRzID0gRG90ZW52TW9kdWxlXG4iXSwibmFtZXMiOlsiZnMiLCJyZXF1aXJlIiwicGF0aCIsIm9zIiwiY3J5cHRvIiwicGFja2FnZUpzb24iLCJ2ZXJzaW9uIiwiTElORSIsInBhcnNlIiwic3JjIiwib2JqIiwibGluZXMiLCJ0b1N0cmluZyIsInJlcGxhY2UiLCJtYXRjaCIsImV4ZWMiLCJrZXkiLCJ2YWx1ZSIsInRyaW0iLCJtYXliZVF1b3RlIiwiX3BhcnNlVmF1bHQiLCJvcHRpb25zIiwidmF1bHRQYXRoIiwiX3ZhdWx0UGF0aCIsInJlc3VsdCIsIkRvdGVudk1vZHVsZSIsImNvbmZpZ0RvdGVudiIsInBhcnNlZCIsImVyciIsIkVycm9yIiwiY29kZSIsImtleXMiLCJfZG90ZW52S2V5Iiwic3BsaXQiLCJsZW5ndGgiLCJkZWNyeXB0ZWQiLCJpIiwiYXR0cnMiLCJfaW5zdHJ1Y3Rpb25zIiwiZGVjcnlwdCIsImNpcGhlcnRleHQiLCJlcnJvciIsIl93YXJuIiwibWVzc2FnZSIsImNvbnNvbGUiLCJsb2ciLCJfZGVidWciLCJfbG9nIiwiRE9URU5WX0tFWSIsInByb2Nlc3MiLCJlbnYiLCJkb3RlbnZLZXkiLCJ1cmkiLCJVUkwiLCJwYXNzd29yZCIsImVudmlyb25tZW50Iiwic2VhcmNoUGFyYW1zIiwiZ2V0IiwiZW52aXJvbm1lbnRLZXkiLCJ0b1VwcGVyQ2FzZSIsInBvc3NpYmxlVmF1bHRQYXRoIiwiQXJyYXkiLCJpc0FycmF5IiwiZmlsZXBhdGgiLCJleGlzdHNTeW5jIiwiZW5kc1dpdGgiLCJyZXNvbHZlIiwiY3dkIiwiX3Jlc29sdmVIb21lIiwiZW52UGF0aCIsImpvaW4iLCJob21lZGlyIiwic2xpY2UiLCJfY29uZmlnVmF1bHQiLCJkZWJ1ZyIsIkJvb2xlYW4iLCJxdWlldCIsInByb2Nlc3NFbnYiLCJwb3B1bGF0ZSIsImRvdGVudlBhdGgiLCJlbmNvZGluZyIsIm9wdGlvblBhdGhzIiwicHVzaCIsImxhc3RFcnJvciIsInBhcnNlZEFsbCIsInJlYWRGaWxlU3luYyIsImUiLCJrZXlzQ291bnQiLCJPYmplY3QiLCJzaG9ydFBhdGhzIiwiZmlsZVBhdGgiLCJyZWxhdGl2ZSIsImNvbmZpZyIsImVuY3J5cHRlZCIsImtleVN0ciIsIkJ1ZmZlciIsImZyb20iLCJub25jZSIsInN1YmFycmF5IiwiYXV0aFRhZyIsImFlc2djbSIsImNyZWF0ZURlY2lwaGVyaXYiLCJzZXRBdXRoVGFnIiwidXBkYXRlIiwiZmluYWwiLCJpc1JhbmdlIiwiUmFuZ2VFcnJvciIsImludmFsaWRLZXlMZW5ndGgiLCJkZWNyeXB0aW9uRmFpbGVkIiwib3ZlcnJpZGUiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/dotenv/lib/main.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/dotenv/package.json":
/*!******************************************!*\
  !*** ./node_modules/dotenv/package.json ***!
  \******************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"name":"dotenv","version":"16.6.1","description":"Loads environment variables from .env file","main":"lib/main.js","types":"lib/main.d.ts","exports":{".":{"types":"./lib/main.d.ts","require":"./lib/main.js","default":"./lib/main.js"},"./config":"./config.js","./config.js":"./config.js","./lib/env-options":"./lib/env-options.js","./lib/env-options.js":"./lib/env-options.js","./lib/cli-options":"./lib/cli-options.js","./lib/cli-options.js":"./lib/cli-options.js","./package.json":"./package.json"},"scripts":{"dts-check":"tsc --project tests/types/tsconfig.json","lint":"standard","pretest":"npm run lint && npm run dts-check","test":"tap run --allow-empty-coverage --disable-coverage --timeout=60000","test:coverage":"tap run --show-full-coverage --timeout=60000 --coverage-report=text --coverage-report=lcov","prerelease":"npm test","release":"standard-version"},"repository":{"type":"git","url":"git://github.com/motdotla/dotenv.git"},"homepage":"https://github.com/motdotla/dotenv#readme","funding":"https://dotenvx.com","keywords":["dotenv","env",".env","environment","variables","config","settings"],"readmeFilename":"README.md","license":"BSD-2-Clause","devDependencies":{"@types/node":"^18.11.3","decache":"^4.6.2","sinon":"^14.0.1","standard":"^17.0.0","standard-version":"^9.5.0","tap":"^19.2.0","typescript":"^4.8.4"},"engines":{"node":">=12"},"browser":{"fs":false}}');

/***/ })

};
;